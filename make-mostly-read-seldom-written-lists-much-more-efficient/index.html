<!DOCTYPE html>
<html lang="en" data-theme=""><head>
    <title>Make Mostly Read, Seldom-Written Lists Much More Efficient | </title>	
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-PR2HVYP6QG"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());
	  gtag('config', 'G-PR2HVYP6QG');
	</script>
    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.78.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="">
    
    <link rel="stylesheet"
          href="https://www.davidhaney.io/css/style.min.2b188541d728e8afd69a6f1b8b83f89f2b138d671fb728eff20ff3f3dcf5b55e.css"
          integrity="sha256-KxiFQdco6K/Wmm8bi4P4nysTjWcftyjv8g/z89z1tV4="
          crossorigin="anonymous"
          type="text/css"><link rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" 
    integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" 
    crossorigin="anonymous" />

    
    <link rel="shortcut icon" href="https://www.davidhaney.io/favicons/favicon.icofavicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="https://www.davidhaney.io/favicons/favicon.icoapple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://www.davidhaney.io/favicons/favicon.icofavicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://www.davidhaney.io/favicons/favicon.icofavicon-16x16.png">

    <link rel="canonical" href="https://www.davidhaney.io/make-mostly-read-seldom-written-lists-much-more-efficient/">

    
    
    
    
    <script type="text/javascript"
            src="https://www.davidhaney.io/js/anatole-header.min.e782db136ec18d105a4552702eac49f4620d6867da3fbf808bd53e806c96be6e.js"
            integrity="sha256-54LbE27BjRBaRVJwLqxJ9GINaGfaP7&#43;Ai9U&#43;gGyWvm4="
            crossorigin="anonymous"></script>
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Make Mostly Read, Seldom-Written Lists Much More Efficient"/>
<meta name="twitter:description" content="One of the many things that I do at work is run a full-blown Search Engine which I also developed from scratch. This Search Engine feeds all product related information to our websites. A search index consists of a pre-computed collection of products, their properties, a list of words that are correctly spelled, and some pre-computed faceted/guided navigation. A search index, until this week, took up approximately 10.7 gigs of memory."/>

</head>
<body><div class="sidebar animated fadeInDown">
    <div class="logo-title">
        <div class="title">
            <img src="https://www.davidhaney.io" alt="profile picture">
            <h3 title=""><a href="/"></a></h3>
            <div class="description">
                <p></p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy;  2021 </div>
    </div>
</div>
<div class="main">
    <div class="page-top animated fadeInDown">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href=""
                        
                   title="">Blog</a></li>
        
            
            <li><a 
                   href="tags"
                        
                   title="">Tags</a></li>
        
        
        <li class="theme-switch-item">
            <a class="theme-switch" title="Switch Theme">
                <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post animated fadeInDown">
        <div class="post-content">

            <div class="post-title">
                <h3>Make Mostly Read, Seldom-Written Lists Much More Efficient</h3>
                
                    <div class="info">
                        <em class="fa fa-sun-o"></em>
                        <span class="date">Fri, Mar 15, 2013</span>
                        <em class="fa fa-clock-o"></em>
                        <span class="reading-time">8-minute read</span>
                    </div>
                
            </div>

            <p>One of the many things that I do at work is run a full-blown Search Engine which I also developed from scratch. This Search Engine feeds all product related information to our websites. A search index consists of a pre-computed collection of products, their properties, a list of words that are correctly spelled, and some pre-computed faceted/guided navigation. A search index, until this week, took up approximately 10.7 gigs of memory. This was becoming too large as we added new products every single day.</p>
<p>As of writing this, it now takes only 4.8 gigs of memory and is only slightly (1-3%) less performant than before. How did I do it? Believe it or not, a very simple data structure and algorithm change.</p>
<p>In the Search Engine, a product’s properties are a key-value pairing of strings… Things like “isInStock” “1” or “color” “red” etc. We store the properties in a collection, per product. The collection was originally:</p>
<pre><code>Dictionary&lt;string, HashSet&lt;string&gt;&gt; _entityProperties;
</code></pre>
<p>The key of the Dictionary was the property name and the HashSet of strings were the values for that property name (property names are not a “unique” key – a product could have multiple colors for example). I initially chose this data structure because we have a heavy need for DIRECT lookups to property names and values. Methods like HasProperties(string propertyName) and HasProperty(string propertyName, string propertyValue) are essential to the search engine’s function, and need to be performant. Thus, I figured that a Dictionary and HashSet would be best, since both offer O(1) lookup times and the index is read from 10000x more often than it is written to. O(1 + 1) is pretty good when it comes to complexity.</p>
<p>It turns out that there was a simpler, better data structure for my goals which also satisfies the performance requirements of the aforementioned methods.</p>
<p>As you may or may not know (and I learned the hard way), a <code>HashSet&lt;T&gt;</code> is actually not very efficient when you have only a few items in it. A <code>List&lt;T&gt;</code> is actually more performant for small collections (4 or fewer objects with simple <!-- raw HTML omitted -->GetHashCode()<!-- raw HTML omitted --> methods, such as strings, in my testing). This is true even though your average lookup/read case goes from O(1) to (1/2n) since you must traverse the List to find your desired object. The reason that List is faster is that there is no hash key computation, and the <code>List&lt;T&gt;</code> is basically an elastic array and thus takes less memory and has less overhead than a <code>HashSet&lt;T&gt;</code> with the same number of objects in it. Since my product properties typically only consist of 2 or 3 values for a given property name, I changed my data structure to this:</p>
<pre><code>Dictionary&lt;string, List&lt;string&gt;&gt; _entityProperties;
</code></pre>
<p>This shaved approximately 10% off of the memory footprint and brought my memory usage down to 9.6 gigs. The performance was basically identical in all performance tests. This was better than my HashSet, but still not great. I wanted to do better. I was sure that somehow I could do better.</p>
<p>I spent the good part of this week trying – and failing – to design a more efficient data structure than the above. I tried a string Trie with nodes that pointed to another Trie, I tried <!-- raw HTML omitted -->SortedList&lt;TKey, TValue&gt;<!-- raw HTML omitted --> instead of the above, and everything else that I could think of. Yet no matter what I did, the memory stayed the same and the performance was the same or worse. It sucked. I was still sure that somehow I could do better.</p>
<p>Finally, Wednesday morning, I had a thought in the shower (where I do my best thinking): two dimensional Arrays suck. They are well documented to, in general, have worse memory usage metrics than a one dimensional array (a quick Google will fill you in). A Dictionary of Lists is certainly a two dimensional jagged Array of sorts, and it wasn’t doing what I wanted in terms of memory. So, I took another approach and changed my data structure wildly – I flattened it out and made it one dimensional:</p>
<pre><code>List&lt;KeyValuePair&lt;string, string&gt;&gt; _entityProperties;
</code></pre>
<p>Seems insane, right? I go from a Dictionary with an O(1) key lookup to a linear List of all keys and values stored together. And yet, it did the trick for my memory: it went from 9.6 gigs to 4.8 gigs. Half of the amount of memory used. I was stoked.</p>
<p>I saved this memory by both interning strings and taking advantage of the KeyValuePair being a struct. Structs are a lot more efficient than reference types when the object is small, and a KeyValuePair is indeed quite small.</p>
<p>A new problem needed solving, however. Each product has around 60-100 properties associated with it, and I needed them to be accessed efficiently and quickly with near-direct lookups. Traversing the [now giant] List was not acceptable in terms of performance.</p>
<p>As it stood, I went from an O(1 + 1) data structure (key and value lookup costs for Dictionary and HashSet) to an O(1 + 1/2n) data structure (Dictionary and List) and finally to an O(n) data structure (List). And to top it all off, the n in the 1/2n was 3 or 4 where the n in the flat List of KeyValuePair was between 60 and 100. Truly I was getting worse performance with each improvement – at least theoretically. Still, the allure of the memory savings was too great to ignore and I wanted to use this data structure.</p>
<p>It then hit me: why not use <!-- raw HTML omitted -->BinarySearch<!-- raw HTML omitted --> on the <code>List&lt;T&gt;</code> to look up items quickly and keep the List sorted while I add AND be able to check for duplicates before adding? It was certainly worth a shot, since binary search is an O(log n) algorithm which is an improvement over the List’s O(n) traversal. So, I modified my Add(string propertyName, string propertyValue) method to keep the List sorted as things were added to it. This is surprisingly easy to do.</p>
<blockquote>
<p>note that from here on out I’m simplifying my code greatly to basic concepts from what actually exists in order to avoid giving away trade secrets or violating my NDA and being fired</p>
</blockquote>
<pre><code>public void Add(string propertyName, string propertyValue)
{   
    // TODO: null checks, etc.

    var keyValuePair = new KeyValuePair&lt;string, string&gt;(propertyName, propertyValue);

    // Add property name and value
    // First find the identical item if it exists
    var result = _entityProperties.BinarySearch(keyValuePair, _entityPropertiesComparer);
    // If result is &gt;= 0, already exists, done
    if (result &gt;= 0)
    {
        return;
    }

    // If it does not exist, a one's complement of the returned int tells us WHERE to insert to maintain the sort order
    _entityProperties.Insert(~result, keyValuePair);
}
</code></pre>
<p>The secret here is two-fold:</p>
<ol>
<li>
<p>I created a custom KeyValuePair&lt;string, string&gt; comparer class that implements <code>IComparer&lt;KeyValuePair&lt;string, string&gt;&gt;</code> and basically does a case-insensitive string compare of first the key strings, then the value strings. This IComparer is required by the List’s BinarySearch method to determine the ordering of objects in the List.</p>
</li>
<li>
<p>The BinarySearch method returns a very useful value: a simple integer. If the int is &lt; 0, it means that the item was not found in the List. If it is &gt;= 0, it means that the item was found at the index of the value. If it returns a negative integer, it means not only that it was not found, <strong>but also that the proper index to insert the item at in order to keep the List sorted is the one’s complement of the value.</strong></p>
</li>
</ol>
<p>A super useful return type, indeed. This allows you to add your elements to a List while preserving an order, at the cost of your add being an O(log n) operation instead of a List’s usual O(1) add operation. However, if you don’t add things as much as you read the List (we only adjust the index once a day for example, but read it thousands of times per hour), this can be worthwhile. Additionally, you could add everything in O(1) time and then do a final List <!-- raw HTML omitted -->Sort<!-- raw HTML omitted --> in order to sort the List for a single O(log n) cost if the order of elements does not matter until you’re done adding everything. In my case, the order mattered as I added to the List because I did not ever want to add duplicates (same property name and value). The HashSet handles this for me – Lists do not.</p>
<p>So, now my add costs O(log n) instead of O(n), but the payoff is now my lookups cost O(log n) instead of O(n) as well. I adjusted my earlier mentioned HasProperty and HasProperties methods accordingly:</p>
<pre><code>public List&lt;string&gt; GetSpecificPropertyValues(string propertyName)
{
    // TODO: null checks, etc.

    List&lt;string&gt; result = new List&lt;string&gt;();

    // Binary search the property name - null is the smallest value of string for comparison
    var keyValuePair = new KeyValuePair&lt;string, string&gt;(propertyName, null);
    // One's complement the start index
    var startIndex = ~_entityProperties.BinarySearch(keyValuePair, _entityPropertiesComparer);

    for (int i = startIndex; i &lt; _entityProperties.Count; i++)
    {
        // Leave the loop when the property name no longer matches
        if (!string.Equals(propertyName, _entityProperties[i].Key, 
            StringComparison.OrdinalIgnoreCase))
        {
            // Leave the loop
            break;
        }
                    
        result.Add(_entityProperties[i].Value);
    }

    return result;
}

public bool HasProperty(string propertyName, string propertyValue)
{
    // TODO: null checks, etc.

    // Binary search the property name
    var keyValuePair = new KeyValuePair&lt;string, string&gt;(propertyName, propertyValue);
    var startIndex = _entityProperties.BinarySearch(keyValuePair, _entityPropertiesComparer);
    return startIndex &gt;= 0;
}

public bool HasProperties(string propertyName)
{
    // TODO: null checks, etc.

    // Binary search the property name
    var keyValuePair = new KeyValuePair&lt;string, string&gt;(propertyName, null);
    // One's complement the start index
    var startIndex = ~_entityProperties.BinarySearch(keyValuePair, _entityPropertiesComparer);
    if (startIndex &gt;= _entityProperties.Count)
    {
        return false;
    }

    // Check that the next element matches the property name
    return string.Equals(propertyName, _entityProperties[startIndex].Key, 
        StringComparison.OrdinalIgnoreCase);
}
</code></pre>
<p>Suddenly, I have the same “direct lookup” methods available as I did with my Dictionary and HashSet/List structure, but in a flat List with O(log n) complexity.</p>
<p>This yielded 50% less memory usage and only a 1-3% increase in performance times. A very acceptable trade for the Search Engine.</p>
<p>If you have a <code>List&lt;T&gt;</code> with a lot of objects in it, and performance is key to your application, consider using BinarySearch and/or Sort to access it in a much more efficient way. As long as you can create an <code>IComparer&lt;T&gt;</code> where T is your List objects type, you’ll have a more efficient List.</p>

        </div>
        <div class="post-footer">
            <div class="info">
                <span class="separator"><a class="category" href="/categories/blog/">blog</a></span>

                <span class="separator"><a class="tag" href="/tags/dotnet/">dotnet</a><a class="tag" href="/tags/csharp/">csharp</a><a class="tag" href="/tags/memory/">memory</a><a class="tag" href="/tags/performance/">performance</a><a class="tag" href="/tags/programming/">programming</a></span>

            </div>
        </div>

        
            <div id="fb_comments_container">
                    <h2>comments</h2>
                    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "haney" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                </div>
        
    </div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="https://www.davidhaney.io/js/jquery.min.86b1e8f819ee2d9099a783e50b49dff24282545fc40773861f9126b921532e4c.js"
        integrity="sha256-hrHo&#43;BnuLZCZp4PlC0nf8kKCVF/EB3OGH5EmuSFTLkw="
        crossorigin="anonymous"></script>




<script type="text/javascript"
        src="https://www.davidhaney.io/js/bundle.min.0f9c74cb78f13d1f15f33daff4037c70354f98acfbb97a6f61708966675c3cae.js"
        integrity="sha256-D5x0y3jxPR8V8z2v9AN8cDVPmKz7uXpvYXCJZmdcPK4="
        crossorigin="anonymous"></script>

<script type="text/javascript"
        src="https://www.davidhaney.io/js/medium-zoom.min.92f21c856129f84aeb719459b3e6ac621a3032fd7b180a18c04e1d12083f8aba.js"
        integrity="sha256-kvIchWEp&#43;ErrcZRZs&#43;asYhowMv17GAoYwE4dEgg/iro="
        crossorigin="anonymous"></script>
</body>

</html>
